Object subclass: #Graph	instanceVariableNames: 'vertices edges'	classVariableNames: ''	package: 'CPSC3223-Hw5-Core'!!Graph commentStamp: 'CDavidShaffer 9/5/2019 15:38' prior: 0!An abstract class supporting a protocol for undirected graphs (although subclasses might include directed graphs).Instance Variables:	vertices	<SequenceableCollection>	the vertices in the graph	edges	<SequenceableCollection>	the edges in the graph!!Graph methodsFor: 'accessing' stamp: 'CDavidShaffer 9/5/2019 15:42'!edges	"Do not modify the collection returned by this method!!!!"		^edges! !!Graph methodsFor: 'accessing' stamp: 'CDavidShaffer 9/5/2019 15:42'!vertices	"Do not modify the collection returned by this method!!!!"		^vertices! !!Graph methodsFor: 'adding/removing' stamp: 'CDavidShaffer 9/5/2019 15:42'!removeEdge: anEdge	"remove anEdge from the graph and answer the removed edge"		self subclassResponsibility! !!Graph methodsFor: 'adding/removing' stamp: 'CDavidShaffer 9/5/2019 15:42'!insertEdgeConnecting: vertex1 and: vertex2 containing: object	"insert the specified edge and return it"		self subclassResponsibility! !!Graph methodsFor: 'adding/removing' stamp: 'CDavidShaffer 9/5/2019 15:42'!removeVertex: aVertex	"remove aVertex from the graph and answer aVertex"		self subclassResponsibility! !!Graph methodsFor: 'adding/removing' stamp: 'CDavidShaffer 9/5/2019 15:42'!insertVertexContaining: anObject	"Insert the specified vertex and return it"		self subclassResponsibility! !!Graph methodsFor: 'graph properties' stamp: 'CDavidShaffer 9/5/2019 15:44'!isSimple	"A graph is simple if and only if:		it contains no self loops (edge which starts and ends on the same vertex)		it contains no parallel edges (two edges which start at the same place and end at the same place)"		self subclassResponsibility! !!Graph methodsFor: 'graph properties' stamp: 'CDavidShaffer 9/5/2019 15:44'!isConnected	"A graph is connected if there is a path from any node to any other 	node. Hint: A graph is connected if and only if a traversal starting 	from an arbitrary node will visit every node. Complete your depth 	first traversal method first. Then, in this method, create an instance 	of CollectingVisitor, pass it to your traversal method and when the 	traversal returns check to make sure that every node was visited 	(the visitor will collect nodes once and only once so you only have to 	check the size)."		self subclassResponsibility! !!Graph methodsFor: 'graph properties' stamp: 'CDavidShaffer 9/5/2019 15:47'!isComplete	"A graph is complete if every node is adjacent to every other node (except, possibly, itself)"		self subclassResponsibility! !!Graph methodsFor: 'traversals' stamp: 'CDavidShaffer 9/5/2019 15:44'!depthFirstTraversalFrom: aVertex visitor: aPrePostVisitor	"Traverse our edges/vertices, starting at aVertex, in depth-first 	order. The traversal proceeds as follows:			1) Send preVisit: to aPrePostVisitor (passing aVertex as an argument) 			2) Traverse all vertices adjacent to aVertex that have not already been visited			3) send postVisit: to aPrePostVisitor (again passing aVertex).	A given vertex will never be pre-visited or post-visited more than once. 	You cannot assume anything about aPrePostVisitor expect that it has the two messages listed above.	Do not try to use the visitor to keep a list of visited nodes.  CollectingVisitor is just /an example/ of a visitor	so don't assume you're passed a CollectingVisitor.	Answer self."		self subclassResponsibility! !!Graph methodsFor: 'initialize-release' stamp: 'CDavidShaffer 9/5/2019 15:43'!initialize		edges := OrderedCollection new.	vertices := OrderedCollection new.	^self! !!Graph methodsFor: 'edge properties' stamp: 'CDavidShaffer 9/5/2019 15:41'!endVertices: anEdge	"Answer a SequenceableCollection (of some kind) which contains the 	two end vertices of the supplied edge"		self subclassResponsibility! !!Graph methodsFor: 'edge properties' stamp: 'CDavidShaffer 9/5/2019 15:41'!edgeContaining: anObject		^self edges detect: [:edge | edge value = anObject]! !!Graph methodsFor: 'vertex properties' stamp: 'CDavidShaffer 9/5/2019 15:43'!isVertex: vertex1 adjacentTo: vertex2	"Answer true if vertex1 is adjacent to vertex2, false otherwise"		^(self adjacentVertices: vertex1) includes: vertex2! !!Graph methodsFor: 'vertex properties' stamp: 'CDavidShaffer 9/5/2019 15:43'!vertexOppositeTo: aVertex on: anEdge	"Answer the vertext opposite to aVertex on anEdge"		self subclassResponsibility! !!Graph methodsFor: 'vertex properties' stamp: 'CDavidShaffer 9/5/2019 15:43'!adjacentVertices: aVertex	"Answer a SequenceableCollection (of some kind) which contains all 	vertices adjacent to the one supplied"		self subclassResponsibility! !!Graph methodsFor: 'vertex properties' stamp: 'CDavidShaffer 9/5/2019 15:43'!vertexContaining: anObject		^self vertices detect: [:vertex | vertex value = anObject]! !!Graph methodsFor: 'vertex properties' stamp: 'CDavidShaffer 9/5/2019 15:43'!degree: aVertex		self subclassResponsibility! !!Graph methodsFor: 'vertex properties' stamp: 'CDavidShaffer 9/5/2019 15:43'!incidentEdges: aVertex	"Answer a SequenceableCollection (of some kind) containing all edges 	incident on aVertex"		self subclassResponsibility! !Object subclass: #GraphElement	instanceVariableNames: 'value graph'	classVariableNames: ''	package: 'CPSC3223-Hw5-Core'!!GraphElement commentStamp: 'CDavidShaffer 9/5/2019 15:36' prior: 0!An abstract container for an arbitrary object in a graph.Instance Variables	value	  <Object>	the contents of this holder	graph 	<Graph>	  the graph that contains this graph element!!GraphElement methodsFor: 'accessing' stamp: 'CDavidShaffer 9/5/2019 15:51'!value		^value! !!GraphElement methodsFor: 'accessing' stamp: 'CDavidShaffer 9/5/2019 15:51'!graph: aGraph		graph := aGraph! !!GraphElement methodsFor: 'accessing' stamp: 'CDavidShaffer 9/5/2019 15:51'!value: aValue		value := aValue! !!GraphElement methodsFor: 'accessing' stamp: 'CDavidShaffer 9/5/2019 15:52'!graph		^graph! !!GraphElement methodsFor: 'printing' stamp: 'CDavidShaffer 9/5/2019 15:52'!printOn: aStream		super printOn: aStream.	aStream nextPut: $(.	aStream nextPutAll: self value printString.	aStream nextPut: $)! !GraphElement subclass: #Edge	instanceVariableNames: 'vertex1 vertex2'	classVariableNames: ''	package: 'CPSC3223-Hw5-Core'!!Edge commentStamp: 'CDavidShaffer 9/5/2019 15:37' prior: 0!An undirected edge intended for Graphs implemented using the adjacency list structure.Instance Variables:	vertex1	<Vertex>	one endpoint of this edge	vertex2	<Vertex>	another endpoint of this edge!!Edge methodsFor: 'accessing' stamp: 'CDavidShaffer 9/5/2019 15:53'!mateFor: aVertex	"Answer the vertex opposite to aVertex on this edge"		^aVertex = vertex1		ifTrue: [vertex2]		ifFalse: [vertex1]! !!Edge methodsFor: 'accessing' stamp: 'CDavidShaffer 9/5/2019 15:53'!vertex2		^vertex2! !!Edge methodsFor: 'accessing' stamp: 'CDavidShaffer 9/5/2019 15:53'!vertex1		^vertex1! !!Edge methodsFor: 'initialize-release' stamp: 'CDavidShaffer 9/5/2019 15:55'!initializeWith: v1 and: v2		vertex1 := v1.	vertex2 := v2.	vertex1 addEdge: self.	vertex2 addEdge: self.	^self! !!Edge methodsFor: 'testing' stamp: 'CDavidShaffer 9/5/2019 15:54'!isParallelTo: other		^self vertex1 == other vertex1 & (self vertex2 == other vertex2)		or: [self vertex1 == other vertex2 & (self vertex2 == other vertex1)]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Edge class	instanceVariableNames: ''!!Edge class methodsFor: 'instance creation' stamp: 'CDavidShaffer 9/5/2019 15:54'!newWith: vertex1 and: vertex2		^self new initializeWith: vertex1 and: vertex2.! !Object subclass: #PrePostVisitor	instanceVariableNames: ''	classVariableNames: ''	package: 'CPSC3223-Hw5-Core'!!PrePostVisitor commentStamp: 'CDavidShaffer 9/5/2019 15:38' prior: 0!An abstract class demonstrating the interface required of all graph traveral visitors.This class implements the visiting methods as "no-ops".  Concrete subclasses wouldimplement preVisit: and/or postVisit: to perform some operation upon visiting a node.Instance Variables:!!PrePostVisitor methodsFor: 'visiting' stamp: 'CDavidShaffer 9/5/2019 15:50'!preVisit: aVertex		^self! !!PrePostVisitor methodsFor: 'visiting' stamp: 'CDavidShaffer 9/5/2019 15:50'!postVisit: aVertex		^self! !PrePostVisitor subclass: #CollectingVisitor	instanceVariableNames: 'vertices'	classVariableNames: ''	package: 'CPSC3223-Hw5-Core'!!CollectingVisitor commentStamp: 'CDavidShaffer 9/5/2019 15:39' prior: 0!I am a graph visitor that records the vertices traversed in post order.Instance Variables	vertices	<SequenceableCollection>	vertices visited during the traversal!!CollectingVisitor methodsFor: 'accessing' stamp: 'CDavidShaffer 9/5/2019 16:03'!vertices	^vertices! !!CollectingVisitor methodsFor: 'initialize-release' stamp: 'CDavidShaffer 9/5/2019 15:51'!initialize		vertices := OrderedCollection new! !!CollectingVisitor methodsFor: 'visiting' stamp: 'CDavidShaffer 9/5/2019 15:50'!postVisit: aVertex		vertices add: aVertex! !Object subclass: #SimpleGraphReader	instanceVariableNames: 'stream graphSpecies'	classVariableNames: ''	package: 'CPSC3223-Hw5-Core'!!SimpleGraphReader commentStamp: 'CDavidShaffer 9/5/2019 15:40' prior: 0!This class reads Graphs from a formatted ReadStream.  The format of the stream is quite rigid.  Each graph in the stream is enclosed with lines of the form:	graph <graph name>	...body goes here...	endwhere <graph name> is replaced by the name of the graph without the angle brackets (for example, graph Network).  The body of the graph can contain either node or edge statements of the form	node <node name>	edge <node name> <node name>Nodes must be defined in the file _before_ they can be used in an edge.  When nextGraph is sent to a SimpleGraphReader it skips anything up to a "graph" statement.  That way if there is an error processing one graph in a stream, you can continue with the next graph.See the test class method category for some examples.Instance Variables:	stream			<ReadStream> 	the read stream	graphSpecies	<Class>			The species of the graph to be created!!SimpleGraphReader methodsFor: 'private' stamp: 'CDavidShaffer 9/5/2019 15:57'!graphSpecies: aGraphSubclass		graphSpecies := aGraphSubclass! !!SimpleGraphReader methodsFor: 'private' stamp: 'CDavidShaffer 9/5/2019 15:57'!processNodeLine: line inGraph: aGraph		| name |	name := line		copyFrom: 6		to: line size.	aGraph insertVertexContaining: name! !!SimpleGraphReader methodsFor: 'private' stamp: 'CDavidShaffer 9/5/2019 15:57'!processEdgeLine: line inGraph: aGraph		| v1 v2 space |	space := line findString: ' ' startingAt: 6.	v1 := aGraph		vertexContaining:			(line				copyFrom: 6				to: space - 1).	v2 := aGraph		vertexContaining:			(line				copyFrom: space + 1				to: line size).	aGraph insertEdgeConnecting: v1 and: v2 containing: nil! !!SimpleGraphReader methodsFor: 'initialize-release' stamp: 'CDavidShaffer 9/5/2019 15:56'!initializeOn: aReadStream		stream := aReadStream.	^self! !!SimpleGraphReader methodsFor: 'reading' stamp: 'CDavidShaffer 9/5/2019 15:59'!nextGraph		| result line |	stream upToAll: 'graph '. stream next: 'graph ' size.	result := graphSpecies new.	Transcript		show: 'reading ' , (stream upTo: Character cr);		cr.	"ignore the name for now since Graphs don't support naming"	line := stream upTo: Character cr.	[('end*' match: line) or: [stream atEnd]]		whileFalse:			[('node *' match: line)				ifTrue: [self processNodeLine: line inGraph: result].			('edge *' match: line)				ifTrue: [self processEdgeLine: line inGraph: result].			line := stream upTo: Character cr].	^result! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SimpleGraphReader class	instanceVariableNames: ''!!SimpleGraphReader class methodsFor: 'instance creation' stamp: 'CDavidShaffer 9/5/2019 15:57'!on: aReadStream withGraphSpecies: aGraphSubclass		^super new initializeOn: aReadStream.! !!SimpleGraphReader class methodsFor: 'tests' stamp: 'CDavidShaffer 9/5/2019 15:55'!test1		| graphDef rs reader |	"self test1"	graphDef := 'graph Graph1node Hellonode Goodbyenode farewelledge Hello Goodbyeedge Goodbye farewellend'.	rs := ReadStream on: graphDef.	reader := self on: rs withGraphSpecies: (Smalltalk at: #ALGraph).	reader nextGraph inspect! !GraphElement subclass: #Vertex	instanceVariableNames: 'incidentEdges'	classVariableNames: ''	package: 'CPSC3223-Hw5-Core'!!Vertex commentStamp: 'CDavidShaffer 9/5/2019 15:40' prior: 0!A vertex intended for use in a graph which is represented using an adjacency list structure.Instance Variables:	incidentEdges	<SequenceableCollection>	collection of edges incident on this vertex!!Vertex methodsFor: 'edges' stamp: 'CDavidShaffer 9/5/2019 15:52'!addEdge: anEdge		incidentEdges add: anEdge! !!Vertex methodsFor: 'edges' stamp: 'CDavidShaffer 9/5/2019 15:52'!removeEdge: anEdge	"Remove anEdge from our incident edges and return it"		^incidentEdges remove: anEdge! !!Vertex methodsFor: 'accessing' stamp: 'CDavidShaffer 9/5/2019 15:52'!incidentEdges		^incidentEdges! !!Vertex methodsFor: 'initialize-release' stamp: 'CDavidShaffer 9/5/2019 15:53'!initialize		incidentEdges := OrderedCollection new.	^self! !